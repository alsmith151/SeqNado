from itertools import chain
from pathlib import Path
from typing import List
from loguru import logger
from pydantic import BaseModel, Field

from seqnado import Assay, PileupMethod, DataScalingTechnique, PeakCallingMethod
from seqnado.config import SeqnadoConfig
from seqnado.inputs import (
    FastqCollectionForIP,
    FastqCollection,
    SampleGroupings,
    CollectionLike,
    BamCollection,
    BigWigCollection
)
from seqnado.outputs.files import (
    BigWigFiles,
    FileCollection,
    HeatmapFiles,
    HubFiles,
    PeakCallingFiles,
    PlotFiles,
    QCFiles,
    QuantificationFiles,
    SpikeInFiles,
    SNPFilesRaw,
    SNPFilesAnnotated,
    MethylationFiles,
    ContactFiles,
    GeoSubmissionFiles,
)


class SeqnadoOutputFiles(BaseModel):
    """Collection of output files generated by SeqNado."""

    files: list[str] = Field(default_factory=list)
    sample_names: List[str] = Field(default_factory=list)
    sample_groups: SampleGroupings | None = None

    @property
    def all_files(self) -> List[str]:
        """Return all files in the output collection."""
        return self.files

    def _filter_by_suffix(self, suffix: str, contains: str | None = None):
        """Filter files by suffix and optional substring.

        Args:
            suffix (str): The file suffix to filter by.
            contains (str, optional): A substring that must be present in the file name.
                Defaults to None, meaning no additional filtering.

        Returns:
            List[str]: A list of files that match the criteria.
        """
        return [
            f
            for f in self.files
            if f.endswith(suffix) and (contains in f if contains else True)
        ]

    @property
    def bigwig_files(self):
        return self._filter_by_suffix(".bigWig")

    def select_bigwig_subtype(
        self,
        method: PileupMethod = PileupMethod.DEEPTOOLS,
        scale: DataScalingTechnique = DataScalingTechnique.UNSCALED,
    ):
        """Select bigWig files of a specific subtype.

        Args:
            method (PileupMethod): The pileup method to filter by.
            scale (ScaleMethod): The scale method to filter by.

        Returns:
            List[str]: A list of bigWig files matching the specified subtype.
        """
        return [
            f
            for f in self.files
            if f.endswith(".bigWig") and (method.value in f) and (scale.value in f)
        ]

    @property
    def peak_files(self):
        return self._filter_by_suffix(".bed")
    
    @property
    def bigbed_files(self):
        return self._filter_by_suffix(".bigBed")

    @property
    def has_consensus_peaks(self):
        """Check if consensus peaks are present in the output files."""
        return any(
            f.endswith(".bed") and DataScalingTechnique.MERGED.value in f
            for f in self.files
        )

    @property
    def heatmap_files(self):
        return self._filter_by_suffix(".pdf", "heatmap")
    
    @property
    def genome_browser_plots(self):
        return self._filter_by_suffix(".pdf", "genome_browser")

class SeqnadoOutputBuilder:
    def __init__(
        self,
        assay: Assay,
        samples: CollectionLike,
        config: SeqnadoConfig,
        sample_groupings: SampleGroupings | None = None,
    ):
        """Initializes the SeqnadoOutputBuilder with the given assay, samples, and configuration.
        Args:
            assay (Assay): The type of assay being processed.
            samples (SampleCollection | IPSampleCollection): The collection of samples to process.
            config (SeqnadoConfig): The configuration for the SeqNado project.
            sample_groupings (Optional[SampleGroupings]): Optional groups of samples for merging.
                If provided, will be used to create grouped bigwig files and grouped peak files.
        Raises:
            ValueError: If the provided assay is not supported or if sample groups are provided
                but not defined in the configuration.
        """

        self.assay = assay
        self.samples = samples
        self.config = config
        self.sample_groupings = sample_groupings

        # Initialize an empty list to hold file collections
        self.file_collections: list[FileCollection] = []

    def add_qc_files(self) -> None:
        """Add quality control files to the output collection."""
        qc_files = QCFiles(assay=self.assay, samples=self.samples)
        self.file_collections.append(qc_files)

    def add_individual_bigwig_files(self) -> None:
        """Add individual bigwig files to the output collection."""
        # Default to UNSCALED when scale_methods aren't provided in config
        scale_methods = getattr(
            getattr(self.config.assay_config, "bigwigs", object()),
            "scale_methods",
            [DataScalingTechnique.UNSCALED],
        )
        bigwig_files = BigWigFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            pileup_methods=self.config.assay_config.bigwigs.pileup_method,
            scale_methods=scale_methods,
        )
        self.file_collections.append(bigwig_files)

    def add_grouped_bigwig_files(self) -> None:
        """Add grouped bigwig files to the output collection."""

        scale_methods = getattr(
            getattr(self.config.assay_config, "bigwigs", object()),
            "scale_methods",
            [DataScalingTechnique.UNSCALED],
        )
        for group_name, sample_groups in self.sample_groupings.groupings.items():
            for group in sample_groups.groups:
                bigwig_files = BigWigFiles(
                    assay=self.assay,
                    names=[group.name],
                    pileup_methods=self.config.assay_config.bigwigs.pileup_method,
                    scale_methods=scale_methods,
                )
            self.file_collections.append(bigwig_files)

    def add_peak_files(self) -> None:
        """Add peak files to the output collection."""

        # If starting from bigwigs, only lanceotron is allowed any other raises an error
        if isinstance(self.samples, BigWigCollection):
            if (
                self.config.assay_config.peak_calling
                and self.config.assay_config.peak_calling.method != [PeakCallingMethod.LANCEOTRON]
            ):
                raise ValueError(f"For BigWigCollection, only {PeakCallingMethod.LANCEOTRON} is allowed.")

        peaks = PeakCallingFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            peak_calling_method=self.config.assay_config.peak_calling.method,
        )
        self.file_collections.append(peaks)

    def add_grouped_peak_files(self) -> None:
        """Add grouped peak files to the output collection."""

        for _, sample_groups in self.sample_groupings.groupings.items():
            for group in sample_groups.groups:
                peaks = PeakCallingFiles(
                    assay=self.assay,
                    names=[group.name],
                    peak_calling_method=self.config.assay_config.peak_calling.method,
                )
                self.file_collections.append(peaks)

    def add_bigbed_files(self) -> None:
        """Add bigBed files to the output collection."""
        scale_methods = getattr(
            getattr(self.config.assay_config, "bigwigs", object()),
            "scale_methods",
            [DataScalingTechnique.UNSCALED],
        )
        bigbed_files = BigWigFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            pileup_methods=self.config.assay_config.bigwigs.pileup_method,
            scale_methods=scale_methods,
            prefix=Path("seqnado_output/bigbeds/"),
        )
        self.file_collections.append(bigbed_files)

    def add_heatmap_files(self) -> None:
        """Add heatmap files to the output collection."""
        heatmaps = HeatmapFiles(assay=self.assay)
        self.file_collections.append(heatmaps)

    def add_hub_files(self) -> None:
        """Add hub files to the output collection."""
        hub_files = HubFiles(
            hub_dir=Path("seqnado_output/hub"),
            hub_name=self.config.assay_config.ucsc_hub.name,
        )
        self.file_collections.append(hub_files)

    def add_spikein_files(self) -> None:
        """Add spike-in files to the output collection."""
        spikein_files = SpikeInFiles(
            assay=self.assay,
            names=self.samples.sample_names,
        )
        self.file_collections.append(spikein_files)

    def add_plot_files(self) -> None:
        """Add plot files to the output collection."""
        plot_files = PlotFiles(
            coordinates=self.config.assay_config.plotting.coordinates,
            file_format=self.config.assay_config.plotting.file_format,
        )
        self.file_collections.append(plot_files)

    def add_snp_files(self) -> None:
        """Add SNP files to the output collection."""
        snp_files_raw = SNPFilesRaw(
            assay=self.assay,
            names=self.samples.sample_names,
        )
        self.file_collections.append(snp_files_raw)

        if self.config.assay_config.snp_calling.annotate_snps:
            snp_files_annotated = SNPFilesAnnotated(
                assay=self.assay,
                names=self.samples.sample_names,
            )
            self.file_collections.append(snp_files_annotated)

    def add_methylation_files(self) -> None:
        """Add methylation files to the output collection."""
        methylation_files = MethylationFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            method=self.config.assay_config.methylation.method,
        )
        self.file_collections.append(methylation_files)

    def add_contact_files(self) -> None:
        """Add contact files to the output collection."""
        contact_files = ContactFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            prefix=Path("seqnado_output/mcc/"),
        )
        self.file_collections.append(contact_files)

    def add_quantification_files(self) -> None:
        """Add quantification files to the output collection."""
        quantification_files = QuantificationFiles(
            assay=self.assay,
            methods=self.config.assay_config.quantification.methods,
            names=self.samples.sample_names,
            groups=self.sample_groupings,
            prefix=Path("seqnado_output/quantification/"),
        )
        self.file_collections.append(quantification_files)

    def add_geo_submission_files(self) -> None:
        """Add files for GEO submission.

        **Note**: This method builds the output files collection
        and appends it to the file_collections list. So it should be called
        after all other file collections have been added if you want to include GEO files in the final output.
        """

        if isinstance(self.samples, (BamCollection, BigWigCollection)):
            raise ValueError("GEO submission files can only be generated from FASTQ inputs.")

        outfiles = self.build().all_files
        geo_files = GeoSubmissionFiles(
            assay=self.assay, names=self.samples.sample_names, seqnado_files=outfiles
        )
        self.file_collections.append(geo_files)

    def build(self) -> SeqnadoOutputFiles:
        """Builds the output files collection based on the added file collections."""
        all_files = list(
            chain.from_iterable(p.files for p in self.file_collections if p.files)
        )
        return SeqnadoOutputFiles(
            files=all_files,
            sample_names=self.samples.sample_names,
            sample_groups=self.sample_groupings,
        )


class SeqnadoOutputFactory:
    def __init__(
        self,
        assay: Assay,
        samples: FastqCollection | FastqCollectionForIP,
        config: SeqnadoConfig,
        sample_groupings: SampleGroupings | None = None,
    ):
        self.assay = assay
        self.samples = samples
        self.config = config
        self.sample_groupings = sample_groupings
        self.assay_config = config.assay_config

    def create_output_builder(self) -> SeqnadoOutputBuilder:
        """Creates a SeqnadoOutputBuilder instance with the provided assay, samples, and configuration.

        Returns:
            SeqnadoOutputBuilder: An instance of SeqnadoOutputBuilder configured with the provided parameters.
        Raises:
            ValueError: If the provided assay is not supported or if sample groups are provided
                but not defined in the configuration.
        """
        builder = SeqnadoOutputBuilder(
            assay=self.assay,
            samples=self.samples,
            config=self.config,
            sample_groupings=self.sample_groupings,
        )

        builder.add_qc_files()

        if self.assay_config.create_bigwigs:
            builder.add_individual_bigwig_files()
            if self.sample_groupings:
                builder.add_grouped_bigwig_files()

        if bool(getattr(self.assay_config, "call_peaks", False)):
            builder.add_peak_files()
            if self.sample_groupings.groupings.get('consensus'):
                builder.add_grouped_peak_files()

        if self.assay_config.create_heatmaps:
            builder.add_heatmap_files()

        if self.assay_config.create_ucsc_hub:
            builder.add_hub_files()

        if self.assay_config.create_geo_submission_files:
            builder.add_geo_submission_files()

        if getattr(self.assay_config, "has_spikein", False):
            builder.add_spikein_files()

        if getattr(self.assay_config, "create_quantification_files", False):
            builder.add_quantification_files()

        # Add additional files based on the assay type
        match self.assay:
            case Assay.ATAC | Assay.CHIP | Assay.CAT | Assay.RNA:
                if self.assay_config.plot_with_plotnado:
                    builder.add_plot_files()
            case Assay.SNP:
                builder.add_snp_files()
            case Assay.METH:
                builder.add_methylation_files()
            case Assay.MCC:
                builder.add_contact_files()
            case _:
                logger.debug(f"No additional files to add for assay {self.assay}")

        return builder

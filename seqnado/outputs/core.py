from itertools import chain
from pathlib import Path
from typing import List

from loguru import logger
from pydantic import BaseModel, Field

from seqnado import Assay, DataScalingTechnique, PeakCallingMethod, PileupMethod
from seqnado.config import SeqnadoConfig
from seqnado.inputs import (
    BamCollection,
    BigWigCollection,
    CollectionLike,
    FastqCollection,
    FastqCollectionForIP,
    SampleGroupings,
)
from seqnado.outputs.files import (
    BasicFileCollection,
    BigBedFiles,
    BigWigFiles,
    ContactFiles,
    FileCollection,
    GeoSubmissionFiles,
    HeatmapFiles,
    HubFiles,
    MethylationFiles,
    PeakCallingFiles,
    PlotFiles,
    QCFiles,
    QuantificationFiles,
    SeqNadoReportFile,
    SNPFilesAnnotated,
    SNPFilesRaw,
    SpikeInFiles,
)


class SeqnadoOutputFiles(BaseModel):
    """Collection of output files generated by SeqNado."""

    files: list[str] = Field(default_factory=list)
    sample_names: List[str] = Field(default_factory=list)
    sample_groups: SampleGroupings | None = None

    @property
    def all_files(self) -> List[str]:
        """Return all files in the output collection."""
        return self.files

    def select_files(self, suffix: str, contains: str | None = None, exclude: str | None = None) -> List[str]:
        """Filter files by suffix and optional substring.

        Args:
            suffix (str): The file suffix to filter by.
            contains (str, optional): A substring that must be present in the file name.
                Defaults to None, meaning no additional filtering.
            exclude (str, optional): A substring that must not be present in the file name.
                Defaults to None, meaning no exclusion filtering.

        Returns:
            List[str]: A list of files that match the criteria.
        """
        return [
            f
            for f in self.files
            if f.endswith(suffix) and (contains in f if contains else True) and (exclude not in f if exclude else True)
        ]

    @property
    def bigwig_files(self):
        return self.select_files(".bigWig")

    def select_bigwig_subtype(
        self,
        method: PileupMethod = PileupMethod.DEEPTOOLS,
        scale: DataScalingTechnique = DataScalingTechnique.UNSCALED,
        assay: Assay | None = None,
    ):
        """Select bigWig files of a specific subtype.

        Args:
            method (PileupMethod): The pileup method to filter by.
            scale (ScaleMethod): The scale method to filter by.
            assay (Assay, optional): The assay type to filter by. Defaults to None.

        Returns:
            List[str]: A list of bigWig files matching the specified subtype.
        """

        if assay is not None:
            return [
                f
                for f in self.files
                if f.endswith(".bigWig")
                and (method.value in f)
                and (scale.value in f)
                and (assay.value.lower() in f.lower())
            ]
        else:
            return [
                f
                for f in self.files
                if f.endswith(".bigWig") and (method.value in f) and (scale.value in f)
            ]

    @property
    def peak_files(self):
        return self.select_files(".bed")

    @property
    def bigbed_files(self):
        return self.select_files(".bigBed")

    @property
    def has_consensus_peaks(self):
        """Check if consensus peaks are present in the output files."""
        return any(
            f.endswith(".bed") and DataScalingTechnique.MERGED.value in f
            for f in self.files
        )

    @property
    def heatmap_files(self):
        return self.select_files(".pdf", contains="heatmap")

    @property
    def genome_browser_plots(self):
        return self.select_files(".pdf", contains="genome_browser")
    @property
    def ucsc_hub_files(self):
        return self.select_files(".txt", contains="hub")


class SeqNadoReportFiles:
    def __init__(
        self,
        assay: Assay,
        samples: CollectionLike,
        config: SeqnadoConfig,
        sample_groupings: SampleGroupings = None,
        output_dir: str = "seqnado_output",
    ):
        """Initializes the SeqNadoReportFiles with the given assay, samples, config, sample_groupings, and output directory.
        Args:
            assay (Assay): The type of assay being processed.
            samples (SampleCollection | IPSampleCollection): The collection of samples to process.
            config (SeqnadoConfig): The configuration for the SeqNado project.
            sample_groupings (SampleGroupings, optional): Sample groupings for the project.
            output_dir (str): The output directory for all files. Defaults to "seqnado_output".
        """
        self.assay = assay
        self.samples = samples
        self.config = config
        self.sample_groupings = sample_groupings
        self.output_dir = output_dir

    @property
    def gather_input_files(self) -> List[str]:
        """Gather input files for the SeqNado report, excluding hub and report files.

        Returns:
            List[str]: A list of input file paths for the report.
        """
        builder = SeqnadoOutputBuilder(
            assay=self.assay,
            samples=self.samples,
            config=self.config,
            sample_groupings=self.sample_groupings,
            output_dir=self.output_dir,
        )
        # Add all file types except hub and report
        builder.add_qc_files()

        if (
            "create_bigwigs" in self.config.assay_config
            and self.config.assay_config.create_bigwigs
        ):
            builder.add_individual_bigwig_files()

        if (
            "call_peaks" in self.config.assay_config
            and self.config.assay_config.call_peaks
        ):
            builder.add_peak_files()

        if (
            "create_quantification_files" in self.config.assay_config
            and self.config.assay_config.create_quantification_files
        ):
            builder.add_quantification_files()

        if (
            "has_spikein" in self.config.assay_config
            and self.config.assay_config.has_spikein
        ):
            builder.add_spikein_files()

        if self.assay == Assay.SNP:
            builder.add_snp_files()

        if self.assay == Assay.METH:
            builder.add_methylation_files()

        all_files = builder.build().all_files
        filtered_files = [
            f
            for f in all_files
            if not f.endswith(".hub.txt") and not f.endswith("seqnado_report.html")
        ]
        return filtered_files


class SeqnadoOutputBuilder:
    def __init__(
        self,
        assay: Assay,
        samples: CollectionLike,
        config: SeqnadoConfig,
        sample_groupings: SampleGroupings | None = None,
        output_dir: str = "seqnado_output",
    ):
        """Initializes the SeqnadoOutputBuilder with the given assay, samples, and configuration.
        Args:
            assay (Assay): The type of assay being processed.
            samples (SampleCollection | IPSampleCollection): The collection of samples to process.
            config (SeqnadoConfig): The configuration for the SeqNado project.
            sample_groupings (Optional[SampleGroupings]): Optional groups of samples for merging.
                If provided, will be used to create grouped bigwig files and grouped peak files.
            output_dir (str): The output directory for all files. Defaults to "seqnado_output".
        Raises:
            ValueError: If the provided assay is not supported or if sample groups are provided
                but not defined in the configuration.
        """

        self.assay = assay
        self.samples = samples
        self.config = config
        self.sample_groupings = sample_groupings
        self.output_dir = output_dir

        # Set sample groupings that do provide file names.
        # These need to be used when creating grouped bigwig and peak files.
        self.provide_filenames = ["consensus"]

        # Determine scale methods from config, default to UNSCALED if not specified
        # Default to UNSCALED when scale_methods aren't provided in config
        self.scale_methods = getattr(
            getattr(self.config.assay_config, "bigwigs", object()),
            "scale_methods",
            [DataScalingTechnique.UNSCALED],
        )

        # Initialize an empty list to hold file collections
        self.file_collections: list[FileCollection] = []

    def add_qc_files(self) -> None:
        """Add quality control files to the output collection."""

        qc_files = QCFiles(
            assay=self.assay,
            samples=self.samples,
            output_dir=self.output_dir,
            config=self.config.qc,
        )
        self.file_collections.append(qc_files)

    def add_report_files(self) -> None:
        """Add report files to the output collection."""

        report_file = SeqNadoReportFile(
            output_dir=self.output_dir,
        )
        self.file_collections.append(report_file)

    def add_individual_bigwig_files(self) -> None:
        """Add individual bigwig files to the output collection."""

        bigwig_files = BigWigFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            pileup_methods=self.config.assay_config.bigwigs.pileup_method,
            scale_methods=self.scale_methods,
            output_dir=self.output_dir,
        )
        self.file_collections.append(bigwig_files)

    def add_grouped_bigwig_files(self) -> None:
        """Add grouped bigwig files to the output collection."""

        # Go through the sample groupings e.g. ['consensus', 'scaling']
        for group_name, sample_groups in self.sample_groupings.groupings.items():
            # If the group name is in the list of groups to provide filenames for
            if group_name not in self.provide_filenames:
                continue

            # If we are providing filenames for this group, create bigwig files for each group
            for group in sample_groups.groups:
                bigwig_files = BigWigFiles(
                    assay=self.assay,
                    names=[group.name],
                    pileup_methods=self.config.assay_config.bigwigs.pileup_method,
                    scale_methods=[DataScalingTechnique.MERGED],
                    output_dir=self.output_dir,
                )
                self.file_collections.append(bigwig_files)

    def add_mcc_sentinel_pileup_files(self) -> None:
        """Add MCC sentinel files to the output collection."""
        bigwigs = [
            Path(self.output_dir) / "bigwigs/mcc/.mcc_bigwigs_generated.txt",
        ]
        sentinel_files = BasicFileCollection(files=[str(bw) for bw in bigwigs])
        self.file_collections.append(sentinel_files)

    def add_peak_files(self) -> None:
        """Add peak files to the output collection."""

        # If starting from bigwigs, only lanceotron is allowed any other raises an error
        if isinstance(self.samples, BigWigCollection):
            if (
                self.config.assay_config.peak_calling
                and self.config.assay_config.peak_calling.method
                != [PeakCallingMethod.LANCEOTRON]
            ):
                raise ValueError(
                    f"For BigWigCollection, only {PeakCallingMethod.LANCEOTRON} is allowed."
                )

        # For IP-based assays, only call peaks on IP samples (not controls)
        from seqnado.inputs import FastqCollectionForIP

        if isinstance(self.samples, FastqCollectionForIP):
            sample_names = self.samples.ip_sample_names
        else:
            sample_names = self.samples.sample_names

        peaks = PeakCallingFiles(
            assay=self.assay,
            names=sample_names,
            peak_calling_method=self.config.assay_config.peak_calling.method,
            output_dir=self.output_dir,
        )
        self.file_collections.append(peaks)

    def add_grouped_peak_files(self) -> None:
        """Add grouped peak files to the output collection."""

        # Go through the sample groupings e.g. ['consensus', 'scaling']
        if not self.sample_groupings:
            raise ValueError(
                "Sample groupings must be provided to add grouped peak files."
            )
        if "consensus" not in self.sample_groupings.groupings:
            raise ValueError(
                "Consensus groupings must be defined to add grouped peak files."
            )

        # Create peak files for each consensus group
        for group in self.sample_groupings.groupings["consensus"].groups:
            peaks = PeakCallingFiles(
                assay=self.assay,
                names=[group.name],
                peak_calling_method=self.config.assay_config.peak_calling.method,
                output_dir=self.output_dir,
                is_merged=True,
            )
            self.file_collections.append(peaks)

    def add_bigbed_files(self) -> None:
        """Add bigBed files to the output collection."""

        # Note this will build the bigBed files from the peak files already added
        # So ensure peak files are added before calling this method
        outfiles = self.build().peak_files
        bigbed_files = BigBedFiles(bed_files=outfiles)
        self.file_collections.append(bigbed_files)

    def add_heatmap_files(self) -> None:
        """Add heatmap files to the output collection."""
        heatmaps = HeatmapFiles(assay=self.assay, output_dir=self.output_dir)
        self.file_collections.append(heatmaps)

    def add_hub_files(self) -> None:
        """Add hub files to the output collection."""
        hub_files = HubFiles(
            hub_dir=Path(f"{self.output_dir}/hub"),
            hub_name=self.config.assay_config.ucsc_hub.name,
        )
        self.file_collections.append(hub_files)

    def add_spikein_files(self) -> None:
        """Add spike-in files to the output collection."""
        spikein_files = SpikeInFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            output_dir=self.output_dir,
        )
        self.file_collections.append(spikein_files)

    def add_plot_files(self) -> None:
        """Add plot files to the output collection."""
        plot_files = PlotFiles(
            coordinates=self.config.assay_config.plotting.coordinates,
            file_format=self.config.assay_config.plotting.file_format,
            output_dir=self.output_dir,
        )
        self.file_collections.append(plot_files)

    def add_snp_files(self) -> None:
        """Add SNP files to the output collection."""
        snp_files_raw = SNPFilesRaw(
            assay=self.assay,
            names=self.samples.sample_names,
            output_dir=self.output_dir,
        )
        self.file_collections.append(snp_files_raw)

        if self.config.assay_config.snp_calling.annotate_snps:
            snp_files_annotated = SNPFilesAnnotated(
                assay=self.assay,
                names=self.samples.sample_names,
                output_dir=self.output_dir,
            )
            self.file_collections.append(snp_files_annotated)

    def add_methylation_files(self) -> None:
        """Add methylation files to the output collection."""
        methylation_files = MethylationFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            genomes=self.config.assay_config.methylation.spikein_genomes,
            method=self.config.assay_config.methylation.method,
            output_dir=self.output_dir,
        )
        self.file_collections.append(methylation_files)

    def add_contact_files(self) -> None:
        """Add contact files to the output collection."""
        contact_files = ContactFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            output_dir=f"{self.output_dir}/mcc",
        )
        self.file_collections.append(contact_files)

    def add_quantification_files(self) -> None:
        """Add quantification files to the output collection."""
        # Get the consensus grouping if it exists, otherwise use empty SampleGroups
        if self.sample_groupings and "consensus" in self.sample_groupings.groupings:
            groups = self.sample_groupings.groupings["consensus"]
        else:
            from seqnado.inputs.grouping import SampleGroups

            groups = SampleGroups(groups=[])

        quantification_files = QuantificationFiles(
            assay=self.assay,
            methods=[self.config.assay_config.rna_quantification.method],
            names=self.samples.sample_names,
            groups=groups,
            output_dir=f"{self.output_dir}/quantification",
        )
        self.file_collections.append(quantification_files)

    def add_geo_submission_files(self) -> None:
        """Add files for GEO submission.

        **Note**: This method builds the output files collection
        and appends it to the file_collections list. So it should be called
        after all other file collections have been added if you want to include GEO files in the final output.
        """

        if isinstance(self.samples, (BamCollection, BigWigCollection)):
            raise ValueError(
                "GEO submission files can only be generated from FASTQ inputs."
            )

        outfiles = self.build().all_files
        geo_files = GeoSubmissionFiles(
            assay=self.assay,
            names=self.samples.sample_names,
            seqnado_files=outfiles,
            output_dir=self.output_dir,
        )
        self.file_collections.append(geo_files)

    def build(self) -> SeqnadoOutputFiles:
        """Builds the output files collection based on the added file collections."""
        all_files = list(
            chain.from_iterable(p.files for p in self.file_collections if p.files)
        )
        return SeqnadoOutputFiles(
            files=all_files,
            sample_names=self.samples.sample_names,
            sample_groups=self.sample_groupings,
        )


class MultiomicsOutputBuilder:
    """Defines the output files for multiomics analysis."""

    def __init__(
        self,
        output_dir: Path | None = None,
        assay_outputs: dict[Assay, SeqnadoOutputFiles] | None = None,
    ):
        self.output_dir = output_dir or Path("seqnado_output")
        self.assay_outputs = assay_outputs or {}
        self.file_collections: list[FileCollection] = []

    def add_assay_bigwigs(self) -> list[str]:
        """Get all bigwigs from assay-specific 'all' rules."""
        bigwigs = []
        for assay, output_files in self.assay_outputs.items():
            bws = output_files.bigwig_files
            bigwigs.extend(bws)
        self.file_collections.append(BasicFileCollection(files=bigwigs))

    def add_assay_peaks(self) -> list[str]:
        """Get all peak files from assay-specific 'all' rules."""
        peaks = []
        for assay, output_files in self.assay_outputs.items():
            pks = output_files.peak_files
            peaks.extend(pks)
        self.file_collections.append(BasicFileCollection(files=peaks))

    def add_summary_report(self) -> str:
        """Path to the multiomics summary report."""
        path = str(Path(self.output_dir) / "multiomics_summary.txt")
        self.file_collections.append(BasicFileCollection(files=[path]))

    def add_heatmap(self) -> str:
        """Path to the multiomics heatmap PDF."""
        path = str(Path(self.output_dir) / "multiomics" / "heatmap" / "heatmap.pdf")
        self.file_collections.append(BasicFileCollection(files=[path]))

    def add_metaplot(self) -> str:
        """Path to the multiomics metaplot PDF."""
        path = str(Path(self.output_dir) / "multiomics" / "heatmap" / "metaplot.pdf")
        self.file_collections.append(BasicFileCollection(files=[path]))

    def add_multiomics_dataset(self) -> str:
        """Get the output directory."""
        path = str(
            Path(self.output_dir) / "multiomics" / "dataset" / "dataset_bins.h5ad"
        )
        self.file_collections.append(BasicFileCollection(files=[path]))

    def add_assay_outputs(self) -> None:
        """Add all assay output files to the multiomics output collection."""
        for assay, output_files in self.assay_outputs.items():
            self.file_collections.append(
                BasicFileCollection(files=output_files.all_files)
            )

    def build(self) -> SeqnadoOutputFiles:
        """Builds the output files collection based on the added file collections."""
        all_files = list(
            chain.from_iterable(p.files for p in self.file_collections if p.files)
        )
        return SeqnadoOutputFiles(
            files=all_files,
            sample_names=[],
            sample_groups=None,
        )


class SeqnadoOutputFactory:
    def __init__(
        self,
        assay: Assay,
        samples: FastqCollection | FastqCollectionForIP,
        config: SeqnadoConfig,
        sample_groupings: SampleGroupings | None = None,
        output_dir: str = "seqnado_output",
    ):
        self.assay = assay
        self.samples = samples
        self.config = config
        self.sample_groupings = sample_groupings
        self.assay_config = config.assay_config
        self.output_dir = output_dir

    def create_output_builder(self) -> SeqnadoOutputBuilder:
        """Creates a SeqnadoOutputBuilder instance with the provided assay, samples, and configuration.

        Returns:
            SeqnadoOutputBuilder: An instance of SeqnadoOutputBuilder configured with the provided parameters.
        Raises:
            ValueError: If the provided assay is not supported or if sample groups are provided
                but not defined in the configuration.
        """
        builder = SeqnadoOutputBuilder(
            assay=self.assay,
            samples=self.samples,
            config=self.config,
            sample_groupings=self.sample_groupings,
            output_dir=self.output_dir,
        )

        builder.add_qc_files()
        builder.add_report_files()

        if self.assay_config.create_bigwigs:
            if not self.assay == Assay.MCC:
                builder.add_individual_bigwig_files()
                if self.sample_groupings:
                    builder.add_grouped_bigwig_files()
            else:
                builder.add_mcc_sentinel_pileup_files()

        if bool(getattr(self.assay_config, "call_peaks", False)):
            builder.add_peak_files()
            if self.sample_groupings.groupings.get("consensus"):
                builder.add_grouped_peak_files()

        if self.assay_config.create_heatmaps:
            builder.add_heatmap_files()

        if self.assay_config.create_ucsc_hub:
            builder.add_hub_files()

        if self.assay_config.create_geo_submission_files:
            builder.add_geo_submission_files()

        if getattr(self.assay_config, "has_spikein", False):
            builder.add_spikein_files()

        if getattr(self.assay_config, "create_quantification_files", False):
            builder.add_quantification_files()

        # Add additional files based on the assay type
        match self.assay:
            case Assay.ATAC | Assay.CHIP | Assay.CAT | Assay.RNA:
                if self.assay_config.plot_with_plotnado:
                    builder.add_plot_files()
            case Assay.SNP:
                builder.add_snp_files()
            case Assay.METH:
                builder.add_methylation_files()
            case Assay.MCC:
                builder.add_contact_files()
            case _:
                logger.debug(f"No additional files to add for assay {self.assay}")

        return builder
